<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brain Programming Journey</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.1.0",
    "react-dom/client": "https://esm.sh/react-dom@^19.1.0/client",
    "three": "https://esm.sh/three@0.165.0",
    "three/addons/": "https://esm.sh/three@0.165.0/examples/jsm/",
    "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
    "react/": "https://esm.sh/react@^19.1.0/",
    "three/": "https://esm.sh/three@0.165.0/"
  }
}
</script>
<style>
  body { 
    margin: 0; 
    overflow: hidden; 
    background-color: #f5f5f5;
    font-family: 'Inter', sans-serif;
  }
  canvas { display: block; }
</style>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  <script type="module">
    import React, { useRef, useEffect, useState } from 'react';
    import ReactDOM from 'react-dom/client';
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const PUSH_STRENGTH = 0.8;
    const LERP_FACTOR = 0.08;
    const INTERACTION_RADIUS_SQ = 1.5; 
    const DECAY_FACTOR = 0.95;

    const App = () => {
      const mountRef = useRef(null);
      const [isLoading, setIsLoading] = useState(true);
      const [loadingError, setLoadingError] = useState(null);

      const sceneRef = useRef(null);
      const cameraRef = useRef(null);
      const rendererRef = useRef(null);
      const animationIdRef = useRef(null);
      const brainMeshRef = useRef(null);
      const originalPositionsRef = useRef(null);
      const targetOffsetsRef = useRef(new Map());

      const loadModel = async () => {
        if (!sceneRef.current || !cameraRef.current) return;
        
        setIsLoading(true);
        setLoadingError(null);

        try {
          const loader = new GLTFLoader();
          const gltf = await new Promise((resolve, reject) => {
            loader.load('/brain_hologram.glb', resolve, undefined, reject);
          });
          
          const modelGroup = gltf.scene;

          modelGroup.traverse(child => {
              if (child.isMesh) {
                  // Находим первую же модель и работаем с ней
                  if (!brainMeshRef.current) {
                      brainMeshRef.current = child;
                      // Клонируем исходные позиции вершин
                      originalPositionsRef.current = child.geometry.attributes.position.clone();
                  }
              }
          });

          if (brainMeshRef.current) {
              const box = new THREE.Box3().setFromObject(modelGroup);
              const center = box.getCenter(new THREE.Vector3());
              modelGroup.position.sub(center);

              sceneRef.current.add(modelGroup);
              
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const fov = cameraRef.current.fov * (Math.PI / 180);
              let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
              cameraZ *= 1.8;
              cameraRef.current.position.set(0, 0, cameraZ);
          } else {
              throw new Error("Не удалось найти 3D-модель в файле.");
          }
          
          setIsLoading(false);
        } catch (error) {
          console.error('Ошибка загрузки модели:', error);
          setLoadingError(`Ошибка загрузки: ${error.message}`);
          setIsLoading(false);
        }
      };

      useEffect(() => {
        if (!mountRef.current) return;

        const currentMount = mountRef.current;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        sceneRef.current = scene;

        const camera = new THREE.PerspectiveCamera(75, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1000);
        camera.position.z = 5;
        cameraRef.current = camera;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        currentMount.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambientLight);
        
        const raycaster = new THREE.Raycaster();
        
        const onMouseDown = (event) => {
            if (!currentMount || !cameraRef.current || !brainMeshRef.current || !originalPositionsRef.current) return;
            
            const rect = currentMount.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, cameraRef.current);

            const intersects = raycaster.intersectObject(brainMeshRef.current);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const face = intersection.face;

                // Если у геометрии нет полигонов (например, это облако точек), выходим
                if (!face) return;
                
                // Используем первую вершину полигона, на который кликнули, как центр эффекта
                const hitIndex = face.a;
                
                if (hitIndex !== undefined) {
                    const hitPointOriginalPos = new THREE.Vector3().fromBufferAttribute(originalPositionsRef.current, hitIndex);
                    
                    for (let i = 0; i < originalPositionsRef.current.count; i++) {
                        const currentOriginalPos = new THREE.Vector3().fromBufferAttribute(originalPositionsRef.current, i);
                        const distSq = currentOriginalPos.distanceToSquared(hitPointOriginalPos);
                        
                        if (distSq < INTERACTION_RADIUS_SQ) {
                            let direction = currentOriginalPos.clone().sub(hitPointOriginalPos);
                            if (direction.lengthSq() === 0) {
                                direction.set((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5));
                            }
                            direction.normalize();
                            
                            const strength = PUSH_STRENGTH * (1 - Math.sqrt(distSq) / Math.sqrt(INTERACTION_RADIUS_SQ));
                            const offset = direction.multiplyScalar(strength);
                            
                            const existingOffset = targetOffsetsRef.current.get(i) || new THREE.Vector3();
                            targetOffsetsRef.current.set(i, existingOffset.add(offset));
                        }
                    }
                }
            }
        };
        currentMount.addEventListener('mousedown', onMouseDown);

        const animate = () => {
          animationIdRef.current = requestAnimationFrame(animate);
          
          const brainGroup = scene.children.find(child => child.isGroup);
          const brainMesh = brainMeshRef.current;

          if (brainGroup) {
            brainGroup.rotation.y += 0.003;
          }

          if (brainMesh && originalPositionsRef.current) {
              const currentPositionAttribute = brainMesh.geometry.attributes.position;
              let needsUpdate = false;
              
              for (let i = 0; i < currentPositionAttribute.count; i++) {
                  const currentVec = new THREE.Vector3().fromBufferAttribute(currentPositionAttribute, i);
                  const originalVec = new THREE.Vector3().fromBufferAttribute(originalPositionsRef.current, i);
                  
                  let targetPos = originalVec.clone();
                  const offset = targetOffsetsRef.current.get(i);
                  
                  if (offset) {
                      targetPos.add(offset);
                      
                      currentVec.lerp(targetPos, LERP_FACTOR);
                      
                      offset.multiplyScalar(DECAY_FACTOR);
                      if (offset.lengthSq() < 0.001) {
                          targetOffsetsRef.current.delete(i);
                      }
                      
                      needsUpdate = true;
                  } else {
                      currentVec.lerp(originalVec, LERP_FACTOR);
                      if (currentVec.distanceToSquared(originalVec) > 0.001) {
                          needsUpdate = true;
                      }
                  }
                  
                  currentPositionAttribute.setXYZ(i, currentVec.x, currentVec.y, currentVec.z);
              }
              
              if (needsUpdate) {
                  currentPositionAttribute.needsUpdate = true;
              }
          }

          renderer.render(scene, camera);
        };

        loadModel();
        animate();

        const handleResize = () => {
          if (!currentMount || !camera || !renderer) return;
          
          const newWidth = currentMount.clientWidth;
          const newHeight = currentMount.clientHeight;
          
          camera.aspect = newWidth / newHeight;
          camera.updateProjectionMatrix();
          
          renderer.setSize(newWidth, newHeight);
        };

        window.addEventListener('resize', handleResize);

        return () => {
          if (animationIdRef.current) {
            cancelAnimationFrame(animationIdRef.current);
          }
          if (currentMount && renderer.domElement) {
            currentMount.removeChild(renderer.domElement);
          }
          currentMount.removeEventListener('mousedown', onMouseDown);
          window.removeEventListener('resize', handleResize);
          renderer.dispose();
        };
      }, []);

      return (
        <div className="relative w-screen h-screen bg-gray-100">
          <div ref={mountRef} className="w-full h-full" />
          
          {isLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-gray-100 bg-opacity-90">
              <div className="text-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
                <p className="text-gray-600 font-medium">Загрузка модели мозга...</p>
              </div>
            </div>
          )}
          
          {loadingError && (
            <div className="absolute inset-0 flex items-center justify-center bg-gray-100 bg-opacity-90">
              <div className="text-center max-w-md px-6">
                <div className="text-red-500 mb-4">⚠️</div>
                <h3 className="text-lg font-semibold text-gray-800 mb-2">Ошибка загрузки</h3>
                <p className="text-gray-600 text-sm">{loadingError}</p>
                <button 
                  onClick={() => window.location.reload()} 
                  className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                >
                  Перезагрузить
                </button>
              </div>
            </div>
          )}
          
          {!isLoading && !loadingError && (
            <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 text-center">
              <p className="text-gray-600 font-medium text-lg tracking-wide">
                Твой путь в Brain Programming начинается здесь...
              </p>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>